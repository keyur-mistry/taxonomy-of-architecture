<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Architecture Timeline</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: black;
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      touch-action: none; 
    }
    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      position: absolute;
      top: 0;
      left: 0;
    }
    text {
      fill: white;
      user-select: none;
      pointer-events: none;
    }
    line {
      shape-rendering: crispEdges;
    }
    #reset-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 12px 20px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.5);
      border-radius: 8px;
      cursor: pointer;
      z-index: 100;
      backdrop-filter: blur(5px);
      font-size: 14px;
    }
  </style>
</head>
<body>

<button id="reset-btn">Reset View</button>
<svg id="canvas"></svg>

<script>
  const svg = d3.select("#canvas");
  const group = svg.append("g");

  const startYear = 0;
  const endYear = 2026;
  const pixelsPerYear = 10; 
  
  const projects = [
    { year: 1929, name: "Barcelona Pavilion" },
    { year: 1931, name: "Villa Savoye" },
    { year: 1935, name: "Fallingwater" },
    { year: 1945, name: "860–880 Lake Shore Drive" },
    { year: 1951, name: "Farnsworth House" },
    { year: 1952, name: "Unité d'Habitation" },
    { year: 1958, name: "Seagram Building" },
    { year: 1997, name: "Guggenheim Bilbao" },
    { year: 2004, name: "CCTV Headquarters" }
  ];
  projects.sort((a, b) => a.year - b.year);

  const timelineLayer = group.append("g");
  const projectGroup = group.append("g");

function updateLabels(scale) {
    timelineLayer.selectAll("*").remove();
    projectGroup.selectAll("*").remove();

    const viewWidth = window.innerWidth || document.documentElement.clientWidth;
    const viewHeight = window.innerHeight || document.documentElement.clientHeight;
    const centerY = viewHeight / 2;

    // 1. IMPROVED LEGIBILITY SCALING
    // baseFontSize: how big the text "should" be at this scale
    const baseFontSize = 14 / scale;

    // CLAMPING: 
    // Max: 24/scale (prevents it from being huge when zoomed in)
    // Min: 12/scale (ensures it's always readable when zoomed out)
    const dynamicFontSize = Math.min(Math.max(baseFontSize, 12 / scale), 24 / scale);
    
    const dynamicStrokeWidth = 1 / scale;
    const mainLineThickness = 2 / scale;
    const textPadding = 10 / scale;

    // 2. MAIN LINE
    timelineLayer.append("line")
      .attr("x1", startYear * pixelsPerYear)
      .attr("y1", centerY)
      .attr("x2", endYear * pixelsPerYear)
      .attr("y2", centerY)
      .attr("stroke", "white")
      .attr("stroke-width", mainLineThickness);

    // 3. TICKS
    let yearStep = scale < 0.1 ? 500 : (scale < 0.8 ? 100 : 10);
    for (let year = 0; year <= endYear; year += yearStep) {
      const x = year * pixelsPerYear;
      const isMajor = year % 500 === 0;
      const isCentury = year % 100 === 0;
      let tickH = (isMajor ? 20 : (isCentury ? 12 : 6)) / scale;
      let opacity = isMajor ? 1 : (isCentury ? 0.7 : 0.3);

      timelineLayer.append("line")
        .attr("x1", x).attr("y1", centerY - tickH).attr("x2", x).attr("y2", centerY + tickH)
        .attr("stroke", "white").attr("stroke-width", isMajor ? mainLineThickness : dynamicStrokeWidth).attr("opacity", opacity);

      let showText = (yearStep === 500 && isMajor) || (yearStep === 100 && isCentury) || (yearStep === 10 && (isCentury || year % 50 === 0));
      if (showText) {
        timelineLayer.append("text")
          .attr("x", x + (4 / scale)).attr("y", centerY + tickH + (10 / scale))
          .attr("font-size", `${dynamicFontSize * (isMajor ? 1.2 : 0.9)}px`)
          .attr("font-weight", isMajor ? "bold" : "normal").attr("opacity", opacity).text(year);
      }
    }

    // 4. PROJECTS WITH PROTECTIVE BUFFER
    let lastX = -Infinity;
    let currentStackLevel = 0;
    const minDistance = 180 / scale; 
    const stackHeight = 35 / scale;

    projects.forEach(p => {
      const x = p.year * pixelsPerYear;
      if (x - lastX < minDistance) currentStackLevel++; else currentStackLevel = 0;
      lastX = x;

      // This ensures the line always stays long enough to keep text away from the main axis
      const initialGap = 45 / scale; 
      const offset = initialGap + (currentStackLevel * stackHeight);
      const textTopY = centerY - offset;

      const pG = projectGroup.append("g");
      pG.append("circle").attr("cx", x).attr("cy", centerY).attr("r", 5 / scale).attr("fill", "cyan");
      pG.append("line").attr("x1", x).attr("y1", centerY).attr("x2", x).attr("y2", textTopY).attr("stroke", "white").attr("stroke-width", dynamicStrokeWidth).attr("opacity", 0.6);
      pG.append("text")
        .attr("x", x).attr("y", textTopY)
        .attr("dx", -textPadding)
        .attr("dominant-baseline", "hanging")
        .attr("text-anchor", "end")
        .attr("font-size", `${dynamicFontSize}px`)
        .text(`${p.name} (${p.year})`);
    });
  }

  const zoomBehavior = d3.zoom()
    .filter(e => e.button === 0 || e.button === 1 || e.type === 'touchstart' || e.type === 'wheel')
    .scaleExtent([0.05, 20])
    .on("zoom", (e) => {
      group.attr("transform", e.transform);
      updateLabels(e.transform.k);
    });

  svg.call(zoomBehavior);

  function initializeView() {
    const viewWidth = window.innerWidth || document.documentElement.clientWidth;
    if (viewWidth === 0) { setTimeout(initializeView, 100); return; }
    
    const centerX = (viewWidth / 2) - (1950 * pixelsPerYear);
    const transform = d3.zoomIdentity.translate(centerX, 0).scale(1);
    svg.call(zoomBehavior.transform, transform);
    updateLabels(1);
  }

  window.addEventListener('load', initializeView);
  window.addEventListener('resize', () => updateLabels(d3.zoomTransform(svg.node()).k));

  d3.select("#reset-btn").on("click", () => {
    const centerX = (window.innerWidth / 2) - (1950 * pixelsPerYear);
    svg.transition().duration(750).call(zoomBehavior.transform, d3.zoomIdentity.translate(centerX, 0).scale(1));
  });

  // --- Image Support ---
  function addImageToBoard(url) {
    const img = new Image();
    img.onload = function () {
      const transform = d3.zoomTransform(svg.node());
      const xPos = (window.innerWidth / 2 - transform.x) / transform.k;
      const yPos = (window.innerHeight / 2 - transform.y) / transform.k;
      const currentScale = transform.k;

      group.append("image")
        .attr("href", url)
        .attr("x", xPos - (img.width / 4) / currentScale)
        .attr("y", yPos - (img.height / 4) / currentScale)
        .attr("width", (img.width / 2) / currentScale)
        .attr("height", (img.height / 2) / currentScale)
        .call(d3.drag().on("start", function(e) { 
          d3.select(this).raise(); 
          const el = d3.select(this);
          el.attr("data-dx", e.x - +el.attr("x")).attr("data-dy", e.y - +el.attr("y"));
        }).on("drag", function(e) {
          const el = d3.select(this);
          el.attr("x", e.x - +el.attr("data-dx")).attr("y", e.y - +el.attr("data-dy"));
        }));
    };
    img.src = url;
  }

  document.addEventListener("paste", (e) => {
    if (!e.clipboardData) return;
    const items = e.clipboardData.items;
    for (const item of items) {
      if (item.type.startsWith("image/")) {
        const url = URL.createObjectURL(item.getAsFile());
        addImageToBoard(url);
      }
    }
  });
</script>
</body>
</html>
